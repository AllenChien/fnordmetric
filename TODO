
-> msync
-> import freelist properly
-> MmapPageManager, MallocPageManager, InMemoryDatabase, FileBackedDatabase
-> crc32 instead of fnc32 for checksums?
-> file lock on open
-> proper error handling

SELECT
  [FIELDS]
FROM
  [STREAMS]
WHERE
  [CONDITIONS]
FROM
  [FROM_TIME]
UNITL
  [UNTIL_TIME]
GROUP BY
  [GROUP EXPR]
ALIGN BY
  INTERPOLATION;

You can run it as a standalone timerseries database or as a network of distributed
data collection agents. SQL Syntax, statsd support, c++, bindings for x,z,y jadda
jadda

-- Select number of http error codes in the last hour
SELECT http_status, count(http_status) from http_requests
  WHERE time > -24hours
  GROUP BY http_status;
-- AGGREGATE_LOCKSTEP;

-- Select 90th percentile latency in the last day
SELECT percentile(latency, 90) from latency_metric WHERE time > -24hours;
-- SCAN_LOCKSTEP

-- SELECT error rate with two metrics
SELECT
  ((delta(succesful_requests.count) / delta(errors.count)) * 100) as error_rate,
  FROM
    successful_requests,
    errors
  GROUP BY TIME_WINDOW(5 minutes);

-- SELECT slowest page yesterday

-- SELECT http error rate from one metric

-- JOIN two streams on a non time parameter

   SELECT http_code, time
      FROM http_requests

-- GROUP on time + another field

-- COUNT number of events per time period
SELECT count(*) FROM metric GROUP BY

-- limit, offset;

-- where with logical offset



-> Concepts: Stream, Agents vs Server, Retention Policy

-> functions: sum, avg, percentile, mean, variance, stddev, delta, nth_derivate,
              holtwinters

-> msync safety mode: relaxed (consistent but might loose data), conservative
                      (msync async) and paranoid (msync sync)

-> implicit fields: time, agent, offset

-> UI menu: query / streams
-> streams: local/remote. disk usage, replication status, retention, etc
-> query ui: tabs for: html req equivalent, html embed, etc
-> query safety mode: on/off (check row checksums)
-> malloc page manager
-> example:
  * getting started standalone:
     * create http_reqs stream with statuscode, count
     * select select http error rate
  * getting started distributed
     * agents have metrics with http req time distribution and url
     * graph global req time distribution
     * graph 90th percentile req time per agent
-> renice query threads in agents?
-> annotations / deploy lines?
-> push query down into backend
-> drop-in statsd adapter :)
-> agents that run queries on external data sources (e.g. logfiles)
-> newrelic-like agents that auto-export streams on demand
-> on demand streams :)
-> nagios adapter for alerting
-> http interface? (need to bundle lotsa resources)
-> query cache! :)
-> stream replication
-> optimized for seeks over time ranges
-> row compression / page compression?
-> interactive query UI generates embed html snippets
-> generate embed snippets from ruby api -> rails helper plugin
-> execute multiple queries in parallel in the ui -> get multiple timeseries
   and tables (tabs)
